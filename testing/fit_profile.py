#!/usr/bin/env python

'''
GOAL:
   - To measure the effective radius on a galaxy based on its intensity vs. radius

PROCEDURE:
   - Read in photometry files from photwrapper.py
   - Read in radii from SExtractor catalog
   - Fit a linear function to log10(intensity) vs radius in arcsec
   - fit isophotal quantities
   
BACKGROUND:

EXAMPLE:

from within ipython

%run ~/github/HalphaImaging/fit_profile.py

- an example is written in the 'main' part of the program

WRITTEN BY:
   Rose A. Finn
   July 06, 2017

UPDATES:
- revising to incorporate into halpha gui
- 2019-Sep-10: major update to
  - use fits version of phot tables that are now generated by photwrapper.py
  - implement Becky's method for measuring isophotal radii and mags
'''
import numpy as np
from matplotlib import pyplot as plt
from astropy.io import fits
import argparse
import scipy
import scipy.optimize
import os

def simple_fit(plotsingle=False):
    # function to test fitting in log space
    data1 = np.genfromtxt('pointing-1-118647-R_phot.dat')
    linear_fit(data1[:,0],np.log(data1[:,2]),plotsingle=plotsingle)
    
def linear_fit(x,y,plotsingle=False):
    # testing linear fit to log(intensity) vs radius
    if plotsingle:
        plt.figure()
    cc=np.polyfit(x,y,1)
    xl=np.linspace(0,np.max(x),100)
    yl=np.polyval(cc,xl)
    plt.plot(x,y)
    plt.plot(xl,yl,'r-')
    return cc,xl,yl

def sersic(r,I0,n,k):
    return I0*np.exp(-1*k*r**(1./n))

def sersic_neq1(r,I0,k):
    return I0*np.exp(-k*r)

def read_phot_file(pfile):
    # read in file from uat_measure_ellip_phot
    # return radius in pixels and intensity
    # this is now outdated but leaving in case it's needed
    dat = np.genfromtxt(pfile)
    return dat[:,0],dat[:,1], dat[:,2]

def ratio_error(a,b,erra,errb):
    '''
    propagate error when taking a ratio a/b
    '''
    sigma = np.sqrt((erra/b)**2 + (a*errb/b**2)**2)
    return sigma
                    
class profile():
    def __init__(self, image_name, phot_file, se_file = None,pixelscale = 0.43, label='R'):
        '''
        this is written to take the output files generated by
        photwrapper.py

        these have radius, flux, and surface brightness
        
        '''
        self.image_name = image_name
        self.phot_file = phot_file
        self.pixelscale = pixelscale

        # this is the main part of the program
        base = os.path.basename(image_name)
        self.rootname = os.path.splitext(base)[0]
        # old way of getting filename
        #self.rootname,t = image_name.split('.fit')
        
        self.image_data, self.image_header = fits.getdata(self.image_name, header=True)
        self.xdim,self.ydim = self.image_data.shape
    
        self.read_fits_phot_file()

        if se_file != None:
            self.se_file = se_file
            self.read_se_file()
            self.se_flag = True
        else:
            self.se_flag = False

        self.fit_sersic_n1()
        self.linear_fit()
           
    def read_phot_file(self):
        self.radius, self.enc_flux, self.enc_flux_err, self.intensity, self.intensity_err = read_phot_file(self.phot_file)
        self.radius_arcsec = self.radius*self.pixelscale
        self.intensity_normalized = self.intensity/self.intensity[0]

    def read_fits_phot_file(self):
        self.tab = fits.getdata(self.phot_file)
        # updating lines below to mesh with older way of storing data in an ascii file
        #self.tab.sma_pix, self.tab.flux, self.tab.flux_err, self.tab.sb, self.tab.sb_err = read_phot_file(self.phot_file)
        #self.tab.sma_arcsec = self.tab.sma_pix*self.pixelscale
        self.sb_normalized = self.tab.sb/self.tab.sb[0]
        self.sb_normalized_err = self.tab.sb_err/self.tab.sb[0]


    def read_se_file(self):
        cat = fits.getdata(self.se_file,2)
        self.R90 = cat.FLUX_RADIUS[objectID][0][0]*self.pixelscale
        self.R50 = cat.FLUX_RADIUS[objectID][0][1]*self.pixelscale
        self.R30 = cat.FLUX_RADIUS[objectID][0][2]*self.pixelscale
        self.magauto = cat.MAG_AUTO[objectID][0]

    def plot_lines(self):
        if self.se_flag:
            plt.axvline(x=self.R50,ls='--',label='SE R50=%5.1f'%(self.R50))
        plt.axvline(x=-1./self.cc[0],ls=':',label='log fit R50=%5.1f'%(-1./self.cc[0]))
        plt.axvline(x=1./self.popt[1],ls='-.',label='exp fit R50=%5.1f'%(1./self.popt[1]))
        plt.axvline(x=self.flux_radii[1][0], ls='--',label='phot R50=%5.1f'%(self.flux_radii[1][0]))
    def fit_sersic_n1(self):
        flag = (self.tab.sb > 0)
        self.popt, self.pcov = scipy.optimize.curve_fit(sersic_neq1,self.tab.sma_arcsec[flag],self.tab.sb_erg_sqarcsec[flag])
        
    def linear_fit(self):
        flag = (self.tab.sb > 0)
        self.cc = np.polyfit(self.tab.sma_arcsec[flag],np.log10(self.tab.sb_erg_sqarcsec[flag]),1)
        
    def plot_linear_fit(self):
        xl=np.linspace(0,np.max(self.tab.sma_arcsec),100)
        yl = np.polyval(self.cc,xl)
        plt.plot(xl, 10.**yl, 'k--', label='linear fit to log(I)')
        
    def plot_profiles(self):
        plt.errorbar(self.tab.sma_arcsec,self.tab.sb_erg_sqarcsec,yerr=self.tab.sb_erg_sqarcsec_err,fmt='b.', label=self.rootname,markersize=6)
        #plt.plot(self.tab.sma_arcsec, self.tab.sb_erg_sqarcsec, 'b.', label=self.rootname,markersize=6)
        plt.plot(self.tab.sma_arcsec,sersic_neq1(self.tab.sma_arcsec, *self.popt),'r-',label='exp fit')
        self.plot_linear_fit()
        self.plot_lines()
        y = self.tab.sb_erg_sqarcsec,
        plt.ylim(np.min(y), np.max(y))

        
    def get_isophote_rad(self,sb=None, sberr=None):
        '''
        trying to make this general enough to use with both r and halpha.
        therefore, will pass in the surface brightness quantity that should be used.

        for r-band image, this should be self.tab.sb_mag_sqarcsec

        for halpha image, we are using surface brightness in erg/s/cm^2/arcsec^2.
        I suppose I could just calculate the equivalency and use mag/arcsec^2 for both.
        OR, I can pass in sb to use.  Hmmm...

        Less thinking to pass in sb, so going with that for now.  :)
        '''

        try:

            if sb == None:
                sb = self.tab.sb_mag_sqarcsec
                sberr =self.tab.sb_mag_sqarcsec_err
        except ValueError:
            # will get here is user passes in array for sb
            pass
            
        self.iso_radii = np.zeros([len(self.isophotes),2],'f') # store radius, lower and upper errors
        # isophotal radius where sb = 24 mag/arcsec^2, for example
        for i,refsb in enumerate(self.isophotes):
            self.iso_radii[i,0] = np.interp(refsb,sb,self.tab.sma_arcsec)
            errm = abs(self.iso_radii[i,0] - np.interp(refsb,sb-sberr,self.tab.sma_arcsec))
            errp = abs(self.iso_radii[i,0] - np.interp(refsb,sb+sberr,self.tab.sma_arcsec))            
            # store errors as delta values rather than upper and lower limits
            self.iso_radii[i,1] = max(errm, errp)
        
    def get_fluxradii(self):
        # measure the radii that enclose 25, 50 and 75% of total flux
        self.fluxfrac = [.25,.5,.75]
        # the array self.tab.flux is the enclosed flux as a function of radius
        # set the total flux to the max of this array
        total_flux = np.max(self.tab.flux)
        self.flux_radii = np.zeros([len(self.fluxfrac),2],'f')

        # use linear interpolation to find radius that encloses XX% of total flux
        for i,frac in enumerate(self.fluxfrac):
            self.flux_radii[i,0] = np.interp(frac*total_flux,self.tab.flux,self.tab.sma_arcsec)
            errm = abs(self.flux_radii[i,0] - np.interp(frac*total_flux,self.tab.flux-self.tab.flux_err,self.tab.sma_arcsec))
            errp = abs(self.flux_radii[i,0] - np.interp(frac*total_flux,self.tab.flux+self.tab.flux_err,self.tab.sma_arcsec))
            # store errors as delta values rather than upper and lower limits
            self.flux_radii[:,1] = max(errm, errp)

    def get_isophote_mag(self, sb=None, sberr=None):
        try:
            if sb == None:
                sb = self.tab.sb_mag_sqarcsec
                sberr =self.tab.sb_mag_sqarcsec_err
        except ValueError:
            pass

        self.iso_mag = np.zeros([len(self.isophotes),2],'f')
        for i,refsb in enumerate(self.isophotes):
            self.iso_mag[i,0] = np.interp(refsb,sb, self.tab.mag)
            errm = abs(self.iso_mag[i,0] - np.interp(refsb,sb, self.tab.mag-self.tab.mag_err))
            errp = abs(self.iso_mag[i,0] - np.interp(refsb,sb, self.tab.mag+self.tab.mag_err))
            self.iso_mag[:,1] = max(errm, errp)


class rprofile(profile): # functions specific to r-band data
    '''
    this functions are based on Becky's rSurfFinalbp.py
    '''
    def set_isophotes(self):
        # surface brightness isophotes for measuring radii and fluxes
        self.isophotes = np.array([23.5, 24, 25, 26])

    def becky_measurements(self):
        self.set_isophotes()
        self.get_isophote_rad(sb=self.tab.sb_mag_sqarcsec, sberr=self.tab.sb_mag_sqarcsec_err)
        self.get_fluxradii()
        self.get_isophote_mag(sb=self.tab.sb_mag_sqarcsec, sberr=self.tab.sb_mag_sqarcsec_err)
        self.get_c30()
     
    def get_c30(self):
        # C30 = flux w/in 0.3 r24 / flux w/in r24
        self.c30 = np.zeros(2,'f')
        r24 = self.iso_radii[self.isophotes == 24.][0][0]
        # use linear interpolation to find flux within 0.3*r24
        inner = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux)
        inner_perr = abs(inner - np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux+self.tab.flux_err))
        inner_merr = abs(inner - np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux-self.tab.flux_err))
        inner_err = max(inner_perr,inner_merr)
        self.flux_30r24 = np.array([inner,inner_err],'f')
        # use linear interpolation to find flux  within r24
        outer = np.interp(r24,self.tab.sma_arcsec, self.tab.flux)
        outer_perr = abs(outer - np.interp(r24,self.tab.sma_arcsec, self.tab.flux+self.tab.flux_err))
        outer_merr = abs(outer - np.interp(r24,self.tab.sma_arcsec, self.tab.flux-self.tab.flux_err))
        outer_err = max(outer_perr,outer_merr)
        self.flux_r24 = np.array([outer,outer_err],'f')
        print(inner, outer)
        self.c30[0] = inner/outer
        self.c30[1] = ratio_error(inner,outer,inner_err,outer_err)
        
class haprofile(profile): # functions specific to r-band data
    '''
    this functions are based on Becky's rSurfFinalbp.py
    '''
    def set_isophotes(self):
        # surface brightness isophotes for measuring radii and fluxes
        self.isophotes = np.array([16.5, 17, 17.5]) # these are in erg/s/cm^2/arcsec^2

    def becky_measurements(self):
        self.set_isophotes()
        self.get_isophote_rad(sb=self.tab.sb_erg_sqarcsec, sberr=self.tab.sb_erg_sqarcsec_err)
        self.get_fluxradii()
        self.get_isophote_mag(sb=self.tab.sb_erg_sqarcsec, sberr=self.tab.sb_erg_sqarcsec_err)
        self.get_isophote_flux()

    def total_flux(self):
        '''
        sum flux for regions where sb_snr > 2
        '''

        # find radius where snr drops to 2
        index = np.max(np.where(self.tab.sb_snr>2))
        self.total_flux = np.array([self.flux_erg[index],self.flux_erg_err[index]])
        
    def get_isophote_flux(self):
        sb = self.tab.sb_erg_sqarcsec

        self.iso_flux = np.zeros([len(self.isophotes),2],'f')
        for i,refsb in enumerate(self.isophotes):
            self.iso_flux[i,0] = np.interp(refsb,sb, self.tab.flux_erg)
            errm = abs(self.iso_flux[i,0] - np.interp(refsb,sb, self.tab.flux_erg-self.tab.flux_erg_err))
            errp = abs(self.iso_flux[i,0] - np.interp(refsb,sb, self.tab.flux_erg+self.tab.flux_erg_err))
            # keep max error as the error
            self.iso_flux[:,1] = max(errm,errp)

    def get_r24_stuff(self,r24):
        '''
        pass in r24 that was measured from r-band image

        '''
        # C30 = flux w/in 0.3 r24 / flux w/in r24
        
        self.c30 = np.zeros(2,'f')
        # use linear interpolation to find flux within 0.3*r24
        inner = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg)
        inner_perr = abs(np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg+self.tab.flux_erg_err) - inner)
        inner_merr = abs(inner - np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg-self.tab.flux_erg_err))
        inner_err = max(inner_perr,inner_merr)
        self.flux_30r24 = np.array([inner,inner_err],'f')
        # use linear interpolation to find flux  within r24
        outer = np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg)
        outer_perr = abs(np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg+self.tab.flux_erg_err)-outer)
        outer_merr = abs(outer-np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg-self.tab.flux_erg_err))
        outer_err = max(outer_perr,outer_merr)
        self.flux_r24 = np.array([outer,outer_err],'f')
        self.c30[0] = inner/outer
        self.c30[1] = ratio_error(inner,outer,inner_err,outer_err)

        # find radius that encloses 95% of the Halpha flux that is within r24!
        flux_95r24  =   np.interp(0.95*self.flux_r24[0],self.tab.flux_erg, self.tab.sma_arcsec)
        # calculate radius for 
        errp = abs(flux_95r24 - np.interp(0.95*self.flux_r24[0],self.tab.flux_erg+self.tab.flux_erg_err, self.tab.sma_arcsec))
        errm = abs(flux_95r24 - np.interp(0.95*self.flux_r24[0],self.tab.flux_erg-self.tab.flux_erg_err, self.tab.sma_arcsec))
        # use whichever error is max
        err = max(errp, errm)
        self.flux_95r24 = np.array([flux_95r24, err],'f')
        
                              

    
class dualprofile():

    def __init__(self, rprofile, haprofile):
        '''
        rprofile is the r-band instance of profile

        hprofile is the h-alpha instance of profile

        '''
        self.r = rprofile
        self.ha = haprofile

    def plot_both_profiles(self):
        #plt.plot(self.r.tab.sma_arcsec, self.r.sb_normalized, 'b.', label='R',markersize=6)
        plt.errorbar(self.r.tab.sma_arcsec, self.r.sb_normalized, yerr=self.r.sb_normalized_err,fmt='b.', label='R',markersize=6)
        #plt.plot(self.ha.tab.sma_arcsec, self.ha.sb_normalized, 'c.', label=r'$H\alpha$',markersize=6)
        plt.errorbar(self.ha.tab.sma_arcsec, self.ha.sb_normalized, yerr=self.ha.sb_normalized_err,fmt='c.', label=r'$H\alpha$',markersize=6)
        plt.ylabel(r'$\rm I(r) \ / \ max(I(r))$',fontsize=12)
    def make_3panel_plot(self):
        plt.figure(figsize=(5,8))
        plt.subplots_adjust(top=.925)
    
        for i in range(3):
            plt.subplot(3,1,i+1)
            plt.subplots_adjust(left=.15)
            if i == 0:
                self.r.plot_profiles()
            elif i == 1:
                self.ha.plot_profiles()
            elif i == 2:
                self.plot_both_profiles()
            # plot R and Halpha on the same axis

            plt.legend(loc = 'upper right',fontsize=8)
    
            plt.gca().set_yscale('log')
            if i == 0:
                plt.ylabel('$\mu_r \ (erg/s/cm^2/arcsec^2)$')
                plt.title(self.r.rootname)
            elif i == 1:
                plt.ylabel(r'$\mu_{H\alpha} \ (erg/s/cm^2/arcsec^2)$')
            elif i == 2:
                plt.xlabel('Radius (arcsec)')
                plt.legend(loc = 'upper right',fontsize=12)
                #plt.ylim(1.e-2,2)
            #plt.xlim(-1*.02*np.max(self.r.tab.sma_arcsec),np.max(self.r.tab.sma_arcsec))

        plt.savefig(self.r.rootname+'-radial-profile.png')
        plt.show()


if __name__ == '__main__':
    '''
    setting up for testing
    '''
    nsaid = '18216'
    rimage = 'MKW8-'+nsaid+'-R.fits'
    rphot_table = 'MKW8-'+nsaid+'-R_phot.fits'
    haimage = 'MKW8-'+nsaid+'-CS.fits'
    haphot_table = 'MKW8-'+nsaid+'-CS_phot.fits'
    r = rprofile(rimage, rphot_table, label='R')
    r.becky_measurements()
    ha = haprofile(haimage, haphot_table, label=r"$H\alpha$")
    ha.becky_measurements()
    ha.get_r24_stuff(r.iso_radii[r.isophotes == 24.][0][0])
    both = dualprofile(r,ha)
    both.make_3panel_plot()
    
    '''
        
    # limit radius for fitting to < 2*R90, based on Rband image
    flag = (radius > 0.25*rmax) & (radius < 3.5*rmax)
    flag = radius < rmax


    
    
    print 'R-BAND FIT RESULTS:'
    print 'I0 = %.2f'%(popt[0])
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(1./popt[1])

    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50)
    
    if args.compareNSA:
        # read in NSA file
        nsafile = args.NSApath+'nsa_v0_1_2.fits'
        nsa = fits.getdata(nsafile)
        nsa_index = np.where(nsa.NSAID == int(nsaid))
        print '\nNSA fit results'

        print 'n = %.2f'%(nsa.SERSIC_N[nsa_index][0])
        print 'theta 50 (arcsec)= %.2f'%(nsa.SERSIC_TH50[nsa_index][0])
    print '\nH-ALPHA FIT RESULTS:'
    print 'I0 = %.2f'%(popt_ha[0])
    #print 'n =  %.2f'%(popt_ha[1])
    print 'Re (arcsec)= %.2f'%(1./popt_ha[1])


    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc_ha[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc_ha[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50_ha)
    '''
