#!/usr/bin/env python

'''
GOAL:
   - To measure the effective radius on a galaxy based on its intensity vs. radius

PROCEDURE:
   - Read in photometry files from uat_measure_ellip_phot.py
   - Read in radii from SExtractor catalog
   - Fit a linear function to log10(intensity) vs radius in arcsec

BACKGROUND:

EXAMPLE:

from within ipython

%run ~/github/HalphaImaging/uat_fit_profile.py --cluster pointing-1 --id 118647 --compareNSA

WRITTEN BY:
   Rose A. Finn
   July 06, 2017

UPDATES:
- revising to incorporate into halpha gui
- 2019-Sep-10: major update to use fits version of phot tables that are now generated by photwrapper.py

'''
import numpy as np
from matplotlib import pyplot as plt
from astropy.io import fits
import argparse
import scipy
import scipy.optimize

def simple_fit(plotsingle=False):
    # function to test fitting in log space
    data1 = np.genfromtxt('pointing-1-118647-R_phot.dat')
    linear_fit(data1[:,0],np.log(data1[:,2]),plotsingle=plotsingle)
    
def linear_fit(x,y,plotsingle=False):
    # testing linear fit to log(intensity) vs radius
    if plotsingle:
        plt.figure()
    cc=np.polyfit(x,y,1)
    xl=np.linspace(0,np.max(x),100)
    yl=np.polyval(cc,xl)
    plt.plot(x,y)
    plt.plot(xl,yl,'r-')
    return cc,xl,yl

def sersic(r,I0,n,k):
    return I0*np.exp(-1*k*r**(1./n))

def sersic_neq1(r,I0,k):
    return I0*np.exp(-k*r)

def read_phot_file(pfile):
    # read in file from uat_measure_ellip_phot
    # return radius in pixels and intensity
    dat = np.genfromtxt(pfile)
    return dat[:,0],dat[:,1], dat[:,2]

def ratio_err(a,b,erra,errb):
    sigma = np.sqrt((erra/b)**2 + (a*errb/b**2)**2)
    return sigma
                    
class profile():
    def __init__(self, image_name, phot_file, se_file = None,pixelscale = 0.43, label='R'):
        '''
        this is written to take the output files generated by
        photwrapper.py

        these have radius, flux, and surface brightness
        
        '''
        self.image_name = image_name
        self.phot_file = phot_file
        self.pixelscale = pixelscale

        # this is the main part of the program
        base = os.path.basename(image_name)
        self.rootname = os.path.splitext(base)[0]
        # old way of getting filename
        #self.rootname,t = image_name.split('.fit')
        
        self.image_data, self.image_header = fits.getdata(self.image_name, header=True)
        self.xdim,self.ydim = self.image_data.shape
    
        self.read_fits_phot_file()

        if se_file != None:
            self.se_file = se_file
            self.read_se_file()
            self.se_flag = True
        else:
            self.se_flag = False

        self.fit_sersic_n1()
        self.linear_fit()
           
    def read_phot_file(self):
        self.radius, self.enc_flux, self.enc_flux_err, self.intensity, self.intensity_err = read_phot_file(self.phot_file)
        self.radius_arcsec = self.radius*self.pixelscale
        self.intensity_normalized = self.intensity/self.intensity[0]

    def read_fits_phot_file(self):
        self.tab = fits.getdata(self.phot_file)
        # updating lines below to mesh with older way of storing data in an ascii file
        #self.tab.sma_pix, self.tab.flux, self.tab.flux_err, self.tab.sb, self.tab.sb_err = read_phot_file(self.phot_file)
        #self.tab.sma_arcsec = self.tab.sma_pix*self.pixelscale
        self.tab.sb_normalized = self.tab.sb/self.tab.sb[0]


    def read_se_file(self):
        cat = fits.getdata(self.se_file,2)
        self.R90 = cat.FLUX_RADIUS[objectID][0][0]*self.pixelscale
        self.R50 = cat.FLUX_RADIUS[objectID][0][1]*self.pixelscale
        self.R30 = cat.FLUX_RADIUS[objectID][0][2]*self.pixelscale
        self.magauto = cat.MAG_AUTO[objectID][0]

    def plot_lines(self):
        if self.se_flag:
            plt.axvline(x=self.R50,ls='--',label='SE R50=%5.1f'%(self.R50))
        plt.axvline(x=-1./self.cc[0],ls=':',label='log fit R50=%5.1f'%(-1./self.cc[0]))
        plt.axvline(x=1./self.popt[1],ls='-.',label='exp fit R50=%5.1f'%(1./self.popt[1]))
        
    def fit_sersic_n1(self):
        flag = (self.tab.sb > 0)
        self.popt, self.pcov = scipy.optimize.curve_fit(sersic_neq1,self.tab.sma_arcsec[flag],self.tab.sb[flag])
        
    def linear_fit(self):
        flag = (self.tab.sb > 0)
        self.cc = np.polyfit(self.tab.sma_arcsec[flag],np.log(self.tab.sb[flag]),1)
        
    def plot_linear_fit(self):
        xl=np.linspace(0,np.max(self.tab.sma_arcsec),100)
        yl = np.polyval(self.cc,xl)
        plt.plot(xl, yl, 'r-', label='linear fit to log(I)')
        
    def plot_profiles(self):
        plt.plot(self.tab.sma_arcsec, self.tab.sb, 'b.', label=self.rootname,markersize=6)
        plt.plot(self.tab.sma_arcsec,sersic_neq1(self.tab.sma_arcsec, *self.popt),'r-',label='exp fit')
        self.plot_linear_fit()
        self.plot_lines()

class rprofile(profile): # functions specific to r-band data
    '''
    this functions are based on Becky's rSurfFinalbp.py
    '''
    def get_isophote_rad(self):
        self.isophotes = [23.5, 24, 25, 26]
        self.iso_radii = np.zeros([len(self.isophotes),3],'f') # store radius, lower and upper errors
        # isophotal radius where sb = 24 mag/arcsec^2, for example
        for i,sb in enumerate(self.isophotes):
            self.iso_radii[i,0] = np.interp(sb,self.tab.sb_mag_sqarcsec,self.tab.sma_arcsec)
            self.iso_radii[i,1] = np.interp(sb,self.tab.sb_mag_sqarcsec-self.tab.sb_mag_sqarcsec_err,self.tab.sma_arcsec)
            self.iso_radii[i,2] = np.interp(sb,self.tab.sb_mag_sqarcsec+self.tab.sb_mag_sqarcsec_err,self.tab.sma_arcsec)
        # store errors as delta values rather than upper and lower limits
        self.iso_radii[i,1] = self.iso_radii[i,0] - self.iso_radii[i,1]
        self.iso_radii[i,2] = self.iso_radii[i,2] - self.iso_radii[i,0]
        
    def get_fluxradii(self):
        # measure the radii that enclose 25, 50 and 75% of total flux
        self.fluxfrac = [.25,.5.,75]
        # the array self.tab.flux is the enclosed flux as a function of radius
        # set the total flux to the max of this array
        total_flux = np.max(self.tab,flux)
        self.flux_radii = np.zeros([len(self.fluxfrac),3],'f')

        # use linear interpolation to find radius that encloses XX% of total flux
        for i,frac in enumerate(self.fluxfrac):
            self.flux_radii[i,0] = np.interp(frac*total_flux,self.tab.flux,self.tab.sma_arcsec)
            self.flux_radii[i,1] = np.interp(frac*total_flux,self.tab.flux-self.tab.flux_err,self.tab.sma_arcsec)
            self.flux_radii[i,2] = np.interp(frac*total_flux,self.tab.flux+self.tab.flux_err,self.tab.sma_arcsec)
            
        # store errors as delta values rather than upper and lower limits
        self.flux_radii[i,1] = self.flux_radii[i,0] - self.flux_radii[i,1]
        self.flux_radii[i,2] = self.flux_radii[i,2] - self.flux_radii[i,0]

    def get_isophote_mag(self):
        self.iso_mag = np.zeros([len(self.isophotes),3],'f')
        for i,sb in enumerate(self.isophotes):
            self.iso_mag[i,0] = np.interp(sb,self.tab.sma_arcsec, self.tab.mag)
            self.iso_mag[i,1] = np.interp(sb,self.tab.sma_arcsec, self.tab.mag-self.tab.mag_err)
            self.iso_mag[i,2] = np.interp(sb,self.tab.sma_arcsec, self.tab.mag+self.tab.mag_err)
        # store errors as delta values rather than upper and lower limits
        self.iso_mag[i,1] = self.iso_mag[i,0] - self.iso_mag[i,1]
        self.iso_mag[i,2] = self.iso_mag[i,2] - self.iso_mag[i,0]
            
    def get_c30(self):
        # C30 = flux w/in 0.3 r24 / flux w/in r24
        self.c30 = np.zeros(2,'f')
        r24 = self.iso_radii[self.isophotes == 24,0]
        # use linear interpolation to find flux within 0.3*r24
        inner = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux)
        inner_perr = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux+self.tab.flux_err)
        inner_merr = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux-self.tab.flux_err)
        inner_err = max(inner_perr,inner_merr)
        # use linear interpolation to find flux  within r24
        outer = np.interp(.r24,self.tab.sma_arcsec, self.tab.flux)
        outer_perr = np.interp(r24,self.tab.sma_arcsec, self.tab.flux+self.tab.flux_err)
        outer_merr = np.interp(r24,self.tab.sma_arcsec, self.tab.flux-self.tab.flux_err)
        outer_err = max(outer_perr,outer_merr)
        self.c30[0] = inner/outer
        self.c30[1] = ratio_error(inner,outer,inner_err,outer_err)

                              

    
class dualprofile():

    def __init__(self, rprofile, haprofile):
        '''
        rprofile is the r-band instance of profile

        hprofile is the h-alpha instance of profile

        '''
        self.r = rprofile
        self.ha = haprofile

    def plot_both_profiles(self):
        plt.plot(self.r.tab.sma_arcsec, self.r.intensity_normalized, 'b.', label='R',markersize=6)
        plt.plot(self.ha.tab.sma_arcsec, self.ha.intensity_normalized, 'c.', label=r'$H\alpha$',markersize=6)
        plt.ylabel(r'$\rm I(r) \ / \ max(I(r))$',fontsize=12)
    def make_3panel_plot(self):
        plt.figure(figsize=(5,8))
        plt.subplots_adjust(top=.925)
    
        for i in range(3):
            plt.subplot(3,1,i+1)
            plt.subplots_adjust(left=.15)
            if i == 0:
                self.r.plot_profiles()
            elif i == 1:
                self.ha.plot_profiles()
            elif i == 2:
                self.plot_both_profiles()
            # plot R and Halpha on the same axis

            plt.legend(loc = 'upper right',prop={'size':7})
    
            plt.gca().set_yscale('log')
            if i == 0:
                #plt.ylabel('$ R-band \ Intensity \ (ADU/pixel^2)$')
                plt.title(self.r.rootname)
            elif i == 1:
                plt.ylabel('$Normalized \ Intensity \ (ADU/pixel^2)$')
            elif i == 2:
                plt.xlabel('Radius (arcsec)')
                plt.ylim(1.e-2,2)
            plt.xlim(-1*.02*np.max(self.r.tab.sma_arcsec),np.max(self.r.sma_arcsec))

        plt.savefig(self.r.rootname+'-radial-profile.png')
        plt.show()


if __name__ == '__main__':
    '''
    setting up for testing
    '''
    rimage = 'MKW8-18045-R.fits'
    rphot_table = 'MKW8-18045-R_phot.fits'
    haimage = 'MKW8-18045-CS.fits'
    haphot_table = 'MKW8-18045-CS_phot.fits'
    r = profile(rimage, rphot_table, label='R')
    ha = profile(haimage, haphot_table, label=r"$H\alpha$")
    both = dualprofile(r,ha)
    both.make_3panel_plot()
    
    '''
        
    # limit radius for fitting to < 2*R90, based on Rband image
    flag = (radius > 0.25*rmax) & (radius < 3.5*rmax)
    flag = radius < rmax


    
    
    print 'R-BAND FIT RESULTS:'
    print 'I0 = %.2f'%(popt[0])
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(1./popt[1])

    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50)
    
    if args.compareNSA:
        # read in NSA file
        nsafile = args.NSApath+'nsa_v0_1_2.fits'
        nsa = fits.getdata(nsafile)
        nsa_index = np.where(nsa.NSAID == int(nsaid))
        print '\nNSA fit results'

        print 'n = %.2f'%(nsa.SERSIC_N[nsa_index][0])
        print 'theta 50 (arcsec)= %.2f'%(nsa.SERSIC_TH50[nsa_index][0])
    print '\nH-ALPHA FIT RESULTS:'
    print 'I0 = %.2f'%(popt_ha[0])
    #print 'n =  %.2f'%(popt_ha[1])
    print 'Re (arcsec)= %.2f'%(1./popt_ha[1])


    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc_ha[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc_ha[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50_ha)
    '''
