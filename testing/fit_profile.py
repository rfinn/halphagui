#!/usr/bin/env python

'''
GOAL:
   - To measure the effective radius on a galaxy based on its intensity vs. radius

PROCEDURE:
   - Read in photometry files from photwrapper.py
   - Read in radii from SExtractor catalog
   - Fit a linear function to log10(intensity) vs radius in arcsec
   - fit isophotal quantities
   
BACKGROUND:

EXAMPLE:

from within ipython

%run ~/github/HalphaImaging/fit_profile.py

- an example is written in the 'main' part of the program

WRITTEN BY:
   Rose A. Finn
   July 06, 2017

UPDATES:
- revising to incorporate into halpha gui
- 2019-Sep-10: major update to
  - use fits version of phot tables that are now generated by photwrapper.py
  - implement Becky's method for measuring isophotal radii and mags
'''
import numpy as np
from matplotlib import pyplot as plt
from astropy.io import fits
import argparse
from scipy import interpolate
import scipy.optimize
import os

def simple_fit(plotsingle=False):
    # function to test fitting in log space
    data1 = np.genfromtxt('pointing-1-118647-R_phot.dat')
    linear_fit(data1[:,0],np.log(data1[:,2]),plotsingle=plotsingle)
    
def linear_fit(x,y,plotsingle=False):
    # testing linear fit to log(intensity) vs radius
    if plotsingle:
        plt.figure()
    cc=np.polyfit(x,y,1)
    xl=np.linspace(0,np.max(x),100)
    yl=np.polyval(cc,xl)
    plt.plot(x,y)
    plt.plot(xl,yl,'r-')
    return cc,xl,yl

def sersic(r,I0,n,k):
    return I0*np.exp(-1*k*r**(1./n))

def sersic_neq1(r,I0,k):
    return I0*np.exp(-k*r)

def read_phot_file(pfile):
    # read in file from uat_measure_ellip_phot
    # return radius in pixels and intensity
    # this is now outdated but leaving in case it's needed
    dat = np.genfromtxt(pfile)
    return dat[:,0],dat[:,1], dat[:,2]

def ratio_error(a,b,erra,errb):
    '''
    propagate error when taking a ratio a/b
    '''
    sigma = np.sqrt((erra/b)**2 + (a*errb/b**2)**2)
    return sigma

def interpxy(x,y,xnew,xerr=None,yerr=None):
    '''
    GOAL:
    - get spline function of y vs x
    - evaluate spline at new x values - xnew
    - estimate error in ynew by evaluating spline at x+xerr and x-xerr
    
    INPUT:
    - x
    - y
    - xerr
    - xnew - where you want to evaluate the interpolated function
    
    OUTPUT:
    - ynew
    - ynew_err

    '''

    sfit = interpolate.splrep(x, y)
    ynew = interpolate.splev(xnew,sfit)
    # error estimate
    ynew_err = np.zeros_like(ynew)
    if (xerr is not None) and (yerr is None):
        sfit = interpolate.splrep(x-xerr, y)
        errm = interpolate.splev(xnew,sfit)
        sfit = interpolate.splrep(x+xerr, y)
        errp = interpolate.splev(xnew,sfit)
    elif (yerr is not None) and (xerr in None):
        sfit = interpolate.splrep(x, y-yerr)
        errm = interpolate.splev(xnew,sfit)
        sfit = interpolate.splrep(x, y+yerr)
        errp = interpolate.splev(xnew,sfit)
    elif (yerr is not None) and (xerr is not None):
        sfit = interpolate.splrep(x+xnew, y-yerr)
        errm = interpolate.splev(xnew,sfit)
        sfit = interpolate.splrep(x-xnew, y+yerr)
        errp = interpolate.splev(xnew,sfit)
    if (yerr is not None) or (xerr is not None):
        errm = abs(ynew - errm)
        errp = abs(ynew - errp)
        # save the max value of errm and errp as the error
        for i in range(len(ynew)):
            ynew_err[i] =  np.max([errm[i], errp[i]])
    return ynew, ynew_err

class profile():
    def __init__(self, image_name, phot_file, se_file = None,pixelscale = 0.43, label='R'):
        '''
        this is written to take the output files generated by
        photwrapper.py

        these have radius, flux, and surface brightness
        
        '''
        self.image_name = image_name
        self.phot_file = phot_file
        self.pixelscale = pixelscale

        # this is the main part of the program
        base = os.path.basename(image_name)
        self.rootname = os.path.splitext(base)[0]
        # old way of getting filename
        #self.rootname,t = image_name.split('.fit')
        
        self.image_data, self.image_header = fits.getdata(self.image_name, header=True)
        self.xdim,self.ydim = self.image_data.shape
    
        self.read_fits_phot_file()

        if se_file != None:
            self.se_file = se_file
            self.read_se_file()
            self.se_flag = True
        else:
            self.se_flag = False

        self.fit_sersic_n1()
        self.linear_fit()
           
    def read_phot_file(self):
        self.radius, self.enc_flux, self.enc_flux_err, self.intensity, self.intensity_err = read_phot_file(self.phot_file)
        self.radius_arcsec = self.radius*self.pixelscale
        self.intensity_normalized = self.intensity/self.intensity[0]

    def read_fits_phot_file(self):
        self.tab = fits.getdata(self.phot_file)
        # updating lines below to mesh with older way of storing data in an ascii file
        #self.tab.sma_pix, self.tab.flux, self.tab.flux_err, self.tab.sb, self.tab.sb_err = read_phot_file(self.phot_file)
        #self.tab.sma_arcsec = self.tab.sma_pix*self.pixelscale
        self.sb_normalized = self.tab.sb/self.tab.sb[0]
        self.sb_normalized_err = self.tab.sb_err/self.tab.sb[0]


    def read_se_file(self):
        cat = fits.getdata(self.se_file,2)
        self.R90 = cat.FLUX_RADIUS[objectID][0][0]*self.pixelscale
        self.R50 = cat.FLUX_RADIUS[objectID][0][1]*self.pixelscale
        self.R30 = cat.FLUX_RADIUS[objectID][0][2]*self.pixelscale
        self.magauto = cat.MAG_AUTO[objectID][0]

    def plot_lines(self):
        if self.se_flag:
            plt.axvline(x=self.R50,ls='--',label='SE R50=%5.1f'%(self.R50))
        plt.axvline(x=-1./self.cc[0],ls=':',label='log fit R50=%5.1f'%(-1./self.cc[0]))
        plt.axvline(x=1./self.popt[1],ls='-.',label='exp fit R50=%5.1f'%(1./self.popt[1]))
        plt.axvline(x=self.flux_radii[1][0], ls='--',label='phot R50=%5.1f'%(self.flux_radii[1][0]))
    def fit_sersic_n1(self):
        flag = (self.tab.sb_snr > 2) & (self.tab.sb > 0.)
        self.popt, self.pcov = scipy.optimize.curve_fit(sersic_neq1,self.tab.sma_arcsec[flag],self.tab.sb_erg_sqarcsec[flag])
        
    def linear_fit(self):
        flag = (self.tab.sb_snr > 2) & (self.tab.sb > 0.)
        try:
            self.cc = np.polyfit(self.tab.sma_arcsec[flag],np.log10(self.tab.sb_erg_sqarcsec[flag]),1)
        except:
            print('could not complete linear fit')
            self.linear_fit_flag= False
            self.cc = np.array([0,0])
        
    def plot_linear_fit(self):
        xl=np.linspace(0,np.max(self.tab.sma_arcsec),100)
        yl = np.polyval(self.cc,xl)
        plt.plot(xl, 10.**yl, 'k--', label='linear fit to log(I)')
        
    def plot_profiles(self):
        flag =  (self.tab.sb > 0.)
        plt.errorbar(self.tab.sma_arcsec[flag],self.tab.sb_erg_sqarcsec[flag],yerr=self.tab.sb_erg_sqarcsec_err[flag],fmt='b.', label=self.rootname,markersize=6)
        #plt.plot(self.tab.sma_arcsec, self.tab.sb_erg_sqarcsec, 'b.', label=self.rootname,markersize=6)
        plt.plot(self.tab.sma_arcsec,sersic_neq1(self.tab.sma_arcsec, *self.popt),'r-',label='exp fit')
        self.plot_linear_fit()
        self.plot_lines()
        y = self.tab.sb_erg_sqarcsec[flag & (self.tab.sb_snr > 2)]
        plt.ylim(.25*np.min(y), 2.*np.max(y))

        
    def get_isophote_rad(self,sb=None, sberr=None):
        '''
        trying to make this general enough to use with both r and halpha.
        therefore, will pass in the surface brightness quantity that should be used.

        for r-band image, this should be self.tab.sb_mag_sqarcsec

        for halpha image, we are using surface brightness in erg/s/cm^2/arcsec^2.
        I suppose I could just calculate the equivalency and use mag/arcsec^2 for both.
        OR, I can pass in sb to use.  Hmmm...

        Less thinking to pass in sb, so going with that for now.  :)


        '''
        if sb is None:
            sb = self.tab.sb_mag_sqarcsec
            sberr = self.tab.sb_mag_sqarcsec_err
            funca = np.min
            funcb =  np.max
        else:
            funca = np.max
            funcb = np.min
        rad = self.tab.sma_arcsec
        raderr = None
        # isophotal radius where sb = 24 mag/arcsec^2, for example
        # need to flip arrays because sb is decreasing, and np.interp does not work with this
        #self.iso_radii[:,0] = np.interp(self.isophotes,sb, rad)
        #errm = abs(self.iso_radii[:,0] - np.interp(self.isophotes,sb-sberr,rad))
        #errp = abs(self.iso_radii[:,0] - np.interp(self.isophotes,sb+sberr,rad))

        # switching to spline interpolation b/c np.interp does not like DECREASING x data
        # nor NON-MONOTONIC y data :(
        


        # self.iso_radii[:,0], self.iso_radii[:,1] = interpxy(sb, rad, self.isophotes, xerr=sberr,yerr=raderr)

        # take 3 - just finding out where surface brightness crosses desired thresold
        self.iso_radii = np.zeros([len(self.isophotes),2],'f')
        for i,iphot in enumerate(self.isophotes):
            if sum(sb > iphot) == 0:
                print('profile does not reach sb = ',iphot)
                continue
            elif sum(sb < iphot) == 0:
                print('profile does not reach sb = ',iphot)
                continue
            a = funca(np.where(sb > iphot))
            b = funcb(np.where(sb < iphot))
            if abs(a-b) > 2:
                print('isophotal radius uncertain for isophote = ',iphot)
                print(rad[a],rad[b])
            self.iso_radii[i,0] = np.average([rad[a],rad[b]])
            self.iso_radii[i,1] = np.abs((rad[a]-rad[b])/2)

    def get_fluxradii(self):
        # measure the radii that enclose 25, 50 and 75% of total flux
        self.fluxfrac = np.array([.25,.5,.75])
        # the array self.tab.flux is the enclosed flux as a function of radius
        # set the total flux to the max of this array
        total_flux = np.max(self.tab.flux)
        self.flux_radii = np.zeros([len(self.fluxfrac),2],'f')
        x = self.tab.flux
        xerr = self.tab.flux_err
        y = self.tab.sma_arcsec
        yerr = None

        self.flux_radii[:,0], self.flux_radii[:,1] = interpxy(x, y,self.fluxfrac*total_flux, xerr= xerr, yerr=yerr)

        #for i,ffrac in enumerate(
    def get_isophote_mag(self, sb=None, sberr=None):
        if sb is None:
            sb = self.tab.sb_mag_sqarcsec
            sberr =self.tab.sb_mag_sqarcsec_err
        mag = self.tab.mag
        magerr = self.tab.mag_err
        
        self.iso_mag = np.zeros([len(self.isophotes),2],'f')

        #self.iso_mag[:,0], self.iso_mag[:,1] = interpxy(sb, mag, xerr, self.fluxfrac*total_flux)
        for i,iphot in enumerate(self.isophotes):
            #print(i,iphot)
            if sum(sb > iphot) == 0:
                print('profile does not reach sb = ',iphot)
                continue
            elif sum(sb < iphot) == 0:
                print('profile does not reach sb = ',iphot)
                continue
            #print(np.where(sb > iphot))
            #print(np.where(sb < iphot))
            a = np.min(np.where(sb > iphot))
            b = np.max(np.where(sb < iphot))
            if abs(a-b) > 2:
                print('isophotal radius uncertain for isophote = ',iphot)
            # calculate mean of magnitudes
            m1 = mag[a]
            m2 = mag[b]
            self.iso_mag[i,0] = 2.5*np.log10(2) - 2.5*np.log10(10.**(-1*m1/2.5) + 10**(-1*m2/2.5))
            self.iso_mag[i,1] = np.max([abs(self.iso_mag[i,1] - m1), abs(self.iso_mag[i,1] - m2)]) 
        #print('finished getting isophot mags')


class rprofile(profile): # functions specific to r-band data
    '''
    this functions are based on Becky's rSurfFinalbp.py
    '''
    def set_isophotes(self):
        # surface brightness isophotes for measuring radii and fluxes
        self.isophotes = np.array([24, 25, 25.5])

    def becky_measurements(self):
        self.set_isophotes()
        self.get_isophote_rad()#sb=self.tab.sb_mag_sqarcsec, sberr=self.tab.sb_mag_sqarcsec_err)
        self.get_fluxradii()
        self.get_isophote_mag()#sb=self.tab.sb_mag_sqarcsec, sberr=self.tab.sb_mag_sqarcsec_err)
        self.get_c30()
     
    def get_c30(self):
        # C30 = flux w/in 0.3 r24 / flux w/in r24
        self.c30 = np.zeros(2,'f')
        r24 = self.iso_radii[self.isophotes == 24.][0][0]
        # use linear interpolation to find flux within 0.3*r24
        inner = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg)
        inner_perr = abs(inner - np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg+self.tab.flux_erg_err))
        inner_merr = abs(inner - np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg-self.tab.flux_erg_err))
        inner_err = max(inner_perr,inner_merr)
        self.flux_30r24 = np.array([inner,inner_err],'f')
        # use linear interpolation to find flux  within r24
        outer = np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg)
        outer_perr = abs(outer - np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg+self.tab.flux_erg_err))
        outer_merr = abs(outer - np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg-self.tab.flux_erg_err))
        outer_err = max(outer_perr,outer_merr)
        self.flux_r24 = np.array([outer,outer_err],'f')
        #print(inner, outer)
        self.c30[0] = inner/outer
        self.c30[1] = ratio_error(inner,outer,inner_err,outer_err)
        
class haprofile(profile): # functions specific to r-band data
    '''
    this functions are based on Becky's rSurfFinalbp.py
    '''
    def set_isophotes(self):
        # surface brightness isophotes for measuring radii and fluxes
        self.isophotes = np.array([5.e-17, 17.e-18]) # these are in erg/s/cm^2/arcsec^2
        #self.isophotes = 10.**self.isophotes
    def becky_measurements(self):
        self.set_isophotes()
        self.get_isophote_rad(sb=self.tab.sb_erg_sqarcsec, sberr=self.tab.sb_erg_sqarcsec_err)
        self.get_fluxradii()
        self.get_isophote_mag(sb=self.tab.sb_erg_sqarcsec, sberr=self.tab.sb_erg_sqarcsec_err)
        self.get_isophote_flux()
        self.total_flux()
    def total_flux(self):
        '''
        sum flux for regions where sb_snr > 2
        '''

        # find radius where snr drops to 2
        index = np.max(np.where(self.tab.sb_snr>2))
        self.total_flux = np.array([self.tab.flux_erg[index],self.tab.flux_erg_err[index]])
        
    def get_isophote_flux(self):
        sb = self.tab.sb_erg_sqarcsec

        self.iso_flux = np.zeros([len(self.isophotes),2],'f')
        for i,refsb in enumerate(self.isophotes):
            self.iso_flux[i,0] = np.interp(refsb,sb, self.tab.flux_erg)
            errm = abs(self.iso_flux[i,0] - np.interp(refsb,sb, self.tab.flux_erg-self.tab.flux_erg_err))
            errp = abs(self.iso_flux[i,0] - np.interp(refsb,sb, self.tab.flux_erg+self.tab.flux_erg_err))
            # keep max error as the error
            self.iso_flux[:,1] = max(errm,errp)

    def get_r24_stuff(self,r24):
        '''
        pass in r24 that was measured from r-band image

        '''
        # C30 = flux w/in 0.3 r24 / flux w/in r24
        
        self.c30 = np.zeros(2,'f')
        # use linear interpolation to find flux within 0.3*r24
        inner = np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg)
        inner_perr = abs(np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg+self.tab.flux_erg_err) - inner)
        inner_merr = abs(inner - np.interp(.3*r24,self.tab.sma_arcsec, self.tab.flux_erg-self.tab.flux_erg_err))
        inner_err = max(inner_perr,inner_merr)
        self.flux_30r24 = np.array([inner,inner_err],'f')
        # use linear interpolation to find flux  within r24
        outer = np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg)
        outer_perr = abs(np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg+self.tab.flux_erg_err)-outer)
        outer_merr = abs(outer-np.interp(r24,self.tab.sma_arcsec, self.tab.flux_erg-self.tab.flux_erg_err))
        outer_err = max(outer_perr,outer_merr)
        self.flux_r24 = np.array([outer,outer_err],'f')
        self.c30[0] = inner/outer
        self.c30[1] = ratio_error(inner,outer,inner_err,outer_err)

        # find radius that encloses 95% of the Halpha flux that is within r24!
        flux_95r24  =   np.interp(0.95*self.flux_r24[0],self.tab.flux_erg, self.tab.sma_arcsec)
        # calculate radius for 
        errp = abs(flux_95r24 - np.interp(0.95*self.flux_r24[0],self.tab.flux_erg+self.tab.flux_erg_err, self.tab.sma_arcsec))
        errm = abs(flux_95r24 - np.interp(0.95*self.flux_r24[0],self.tab.flux_erg-self.tab.flux_erg_err, self.tab.sma_arcsec))
        # use whichever error is max
        err = max(errp, errm)
        self.flux_95r24 = np.array([flux_95r24, err],'f')
        
                              

    
class dualprofile():

    def __init__(self, rprofile, haprofile):
        '''
        rprofile is the r-band instance of profile

        hprofile is the h-alpha instance of profile

        '''
        self.r = rprofile
        self.ha = haprofile

    def plot_both_profiles(self):
        #plt.plot(self.r.tab.sma_arcsec, self.r.sb_normalized, 'b.', label='R',markersize=6)
        plt.errorbar(self.r.tab.sma_arcsec, self.r.tab.sb_erg_sqarcsec, yerr=self.r.tab.sb_erg_sqarcsec_err,fmt='b.', label='R',markersize=6)
        #plt.plot(self.ha.tab.sma_arcsec, self.ha.sb_normalized, 'c.', label=r'$H\alpha$',markersize=6)
        flag = self.ha.tab.sb_erg_sqarcsec > 0.
        # scale ha flux by 100
        plt.errorbar(self.ha.tab.sma_arcsec[flag], 100.*self.ha.tab.sb_erg_sqarcsec[flag], yerr=100.*self.ha.tab.sb_erg_sqarcsec_err[flag],fmt='c.', label=r'$H\alpha$',markersize=6)
        plt.ylabel(r'$\rm I(r) \ / \ max(I(r))$',fontsize=12)
        y = 100.*self.ha.tab.sb_erg_sqarcsec[flag & (self.ha.tab.sb_snr > 2)]
        #plt.ylim(.25*np.min(y), 2.*np.max(y))

    def make_3panel_plot(self):
        plt.figure(figsize=(5,8))
        plt.subplots_adjust(top=.925)
    
        for i in range(3):
            plt.subplot(3,1,i+1)
            plt.subplots_adjust(left=.15)
            if i == 0:
                self.r.plot_profiles()
            elif i == 1:
                self.ha.plot_profiles()
            elif i == 2:
                self.plot_both_profiles()
            # plot R and Halpha on the same axis

            plt.legend(loc = 'upper right',fontsize=8)
    
            plt.gca().set_yscale('log')
            if i == 0:
                plt.ylabel('$\mu_r \ (erg/s/cm^2/arcsec^2)$')
                plt.title(self.r.rootname)
            elif i == 1:
                plt.ylabel(r'$\mu_{H\alpha} \ (erg/s/cm^2/arcsec^2)$')
            elif i == 2:
                plt.xlabel('Radius (arcsec)')
                plt.legend(loc = 'upper right',fontsize=12)
                #plt.ylim(1.e-2,2)
            #plt.xlim(-1*.02*np.max(self.r.tab.sma_arcsec),np.max(self.r.tab.sma_arcsec))

        plt.savefig(self.r.rootname+'-radial-profile.png')
        plt.show()


if __name__ == '__main__':
    '''
    setting up for testing
    '''
    nsaid = '18045'
    prefix = 'NRGs27-'
    nsaid = '110430'
    rimage = prefix+nsaid+'-R.fits'
    rphot_table = prefix+nsaid+'-R_phot.fits'
    haimage = prefix+nsaid+'-CS.fits'
    haphot_table = prefix+nsaid+'-CS_phot.fits'
    r = rprofile(rimage, rphot_table, label='R')
    r.becky_measurements()
    ha = haprofile(haimage, haphot_table, label=r"$H\alpha$")
    ha.becky_measurements()
    ha.get_r24_stuff(r.iso_radii[r.isophotes == 24.][0][0])
    both = dualprofile(r,ha)
    both.make_3panel_plot()
    
    '''
        
    # limit radius for fitting to < 2*R90, based on Rband image
    flag = (radius > 0.25*rmax) & (radius < 3.5*rmax)
    flag = radius < rmax


    
    
    print 'R-BAND FIT RESULTS:'
    print 'I0 = %.2f'%(popt[0])
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(1./popt[1])

    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50)
    
    if args.compareNSA:
        # read in NSA file
        nsafile = args.NSApath+'nsa_v0_1_2.fits'
        nsa = fits.getdata(nsafile)
        nsa_index = np.where(nsa.NSAID == int(nsaid))
        print '\nNSA fit results'

        print 'n = %.2f'%(nsa.SERSIC_N[nsa_index][0])
        print 'theta 50 (arcsec)= %.2f'%(nsa.SERSIC_TH50[nsa_index][0])
    print '\nH-ALPHA FIT RESULTS:'
    print 'I0 = %.2f'%(popt_ha[0])
    #print 'n =  %.2f'%(popt_ha[1])
    print 'Re (arcsec)= %.2f'%(1./popt_ha[1])


    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc_ha[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc_ha[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50_ha)
    '''
