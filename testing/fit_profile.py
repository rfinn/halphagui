#!/usr/bin/env python

'''
GOAL:
   - To measure the effective radius on a galaxy based on its intensity vs. radius

PROCEDURE:
   - Read in photometry files from uat_measure_ellip_phot.py
   - Read in radii from SExtractor catalog
   - Fit a linear function to log10(intensity) vs radius in arcsec

BACKGROUND:

EXAMPLE:

from within ipython

%run ~/github/HalphaImaging/uat_fit_profile.py --cluster pointing-1 --id 118647 --compareNSA

WRITTEN BY:
   Rose A. Finn
   July 06, 2017

UPDATES:
- revising to incorporate into halpha gui


'''
import numpy as np
from matplotlib import pyplot as plt
from astropy.io import fits
import argparse
import scipy
import scipy.optimize

def simple_fit(plotsingle=False):
    # function to test fitting in log space
    data1 = np.genfromtxt('pointing-1-118647-R_phot.dat')
    linear_fit(data1[:,0],np.log(data1[:,2]),plotsingle=plotsingle)
    
def linear_fit(x,y,plotsingle=False):
    # testing linear fit to log(intensity) vs radius
    if plotsingle:
        plt.figure()
    cc=np.polyfit(x,y,1)
    xl=np.linspace(0,np.max(x),100)
    yl=np.polyval(cc,xl)
    plt.plot(x,y)
    plt.plot(xl,yl,'r-')
    return cc,xl,yl

def sersic(r,I0,n,k):
    return I0*np.exp(-1*k*r**(1./n))

def sersic_neq1(r,I0,k):
    return I0*np.exp(-k*r)

def read_phot_file(pfile):
    # read in file from uat_measure_ellip_phot
    # return radius in pixels and intensity
    dat = np.genfromtxt(pfile)
    return dat[:,0],dat[:,1], dat[:,2]


class profile():
    def __init__(self, image_name, phot_file, se_file = None,pixelscale = 0.43, label='R'):
        '''
        this is written to take the output files generated by
        photwrapper.py

        these have radius, flux, and surface brightness
        
        '''
        self.image_name = image_name
        self.phot_file = phot_file
        self.pixelscale = pixelscale

        # this is the main part of the program
        self.rootname,t = image_name.split('.fit')
        
        self.image_data = fits.getdata(self.image_name)
        self.xdim,self.ydim = self.image_data.shape
    
        self.read_phot_file()

        if se_file != None:
            self.se_file = se_file
            self.read_se_file()
            self.se_flag = True
        else:
            self.se_flag = False

        self.fit_sersic_n1()
        self.linear_fit()
           
    def read_phot_file(self):
        self.radius, self.enc_flux, self.enc_flux_err, self.intensity, self.intensity_err = read_phot_file(self.phot_file)
        self.radius_arcsec = self.radius*self.pixelscale
        self.intensity_normalized = self.intensity/self.intensity[0]


    def read_se_file(self):
        cat = fits.getdata(self.se_file,2)
        self.R90 = cat.FLUX_RADIUS[objectID][0][0]*self.pixelscale
        self.R50 = cat.FLUX_RADIUS[objectID][0][1]*self.pixelscale
        self.R30 = cat.FLUX_RADIUS[objectID][0][2]*self.pixelscale
        self.magauto = cat.MAG_AUTO[objectID][0]

    def plot_lines(self):
        if self.se_flag:
            plt.axvline(x=self.R50,ls='--',label='SE R50=%5.1f'%(self.R50))
        plt.axvline(x=-1./self.cc[0],ls=':',label='log fit R50=%5.1f'%(-1./self.cc[0]))
        plt.axvline(x=1./self.popt[1],ls='-.',label='exp fit R50=%5.1f'%(1./self.popt[1]))
    def fit_sersic_n1(self):
        flag = (self.intensity > 0)
        self.popt, self.pcov = scipy.optimize.curve_fit(sersic_neq1,self.radius_arcsec[flag],self.intensity[flag])
    def linear_fit(self):
        flag = (self.intensity > 0)
        self.cc = np.polyfit(self.radius_arcsec[flag],np.log(self.intensity[flag]),1)
    def plot_linear_fit(self):
        xl=np.linspace(0,np.max(self.radius_arcsec),100)
        yl = np.polyval(self.cc,xl)
        plt.plot(xl, yl, 'r-', label='linear fit to log(I)')
    def plot_profiles(self):
        plt.plot(self.radius_arcsec, self.intensity, 'b.', label=self.rootname,markersize=6)
        plt.plot(self.radius_arcsec,sersic_neq1(self.radius_arcsec, *self.popt),'r-',label='exp fit')
        self.plot_linear_fit()
        self.plot_lines()

class dualprofile():

    def __init__(self, rprofile, haprofile):
        '''
        rprofile is the r-band instance of profile

        hprofile is the h-alpha instance of profile

        '''
        self.r = rprofile
        self.ha = haprofile

    def plot_both_profiles(self):
        plt.plot(self.r.radius_arcsec, self.r.intensity_normalized, 'b.', label='R',markersize=6)
        plt.plot(self.ha.radius_arcsec, self.ha.intensity_normalized, 'c.', label=r'$H\alpha$',markersize=6)
        plt.ylabel(r'$\rm I(r) \ / \ max(I(r))$',fontsize=12)
    def make_3panel_plot(self):
        plt.figure(figsize=(5,8))
        plt.subplots_adjust(top=.925)
    
        for i in range(3):
            plt.subplot(3,1,i+1)
            plt.subplots_adjust(left=.15)
            if i == 0:
                self.r.plot_profiles()
            elif i == 1:
                self.ha.plot_profiles()
            elif i == 2:
                self.plot_both_profiles()
            # plot R and Halpha on the same axis

            plt.legend(loc = 'upper right',prop={'size':7})
    
            plt.gca().set_yscale('log')
            if i == 0:
                #plt.ylabel('$ R-band \ Intensity \ (ADU/pixel^2)$')
                plt.title(self.r.rootname)
            elif i == 1:
                plt.ylabel('$Normalized \ Intensity \ (ADU/pixel^2)$')
            elif i == 2:
                plt.xlabel('Radius (arcsec)')
                plt.ylim(1.e-2,2)
            plt.xlim(-1*.02*np.max(self.r.radius_arcsec),np.max(self.r.radius_arcsec))

        plt.savefig(self.r.rootname+'-radial-profile.png')
        plt.show()


if __name__ == '__main__':
    '''
    setting up for testing
    '''
    rimage = 'MKW8-18045-R.fits'
    rphot_table = 'MKW8-18045-R_phot.dat'
    haimage = 'MKW8-18045-CS.fits'
    haphot_table = 'MKW8-18045-CS_phot.dat'
    r = profile(rimage, rphot_table, label='R')
    ha = profile(haimage, haphot_table, label=r"$H\alpha$")
    both = dualprofile(r,ha)
    both.make_3panel_plot()
    
    '''
        
    # limit radius for fitting to < 2*R90, based on Rband image
    flag = (radius > 0.25*rmax) & (radius < 3.5*rmax)
    flag = radius < rmax


    
    
    print 'R-BAND FIT RESULTS:'
    print 'I0 = %.2f'%(popt[0])
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(1./popt[1])

    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50)
    
    if args.compareNSA:
        # read in NSA file
        nsafile = args.NSApath+'nsa_v0_1_2.fits'
        nsa = fits.getdata(nsafile)
        nsa_index = np.where(nsa.NSAID == int(nsaid))
        print '\nNSA fit results'

        print 'n = %.2f'%(nsa.SERSIC_N[nsa_index][0])
        print 'theta 50 (arcsec)= %.2f'%(nsa.SERSIC_TH50[nsa_index][0])
    print '\nH-ALPHA FIT RESULTS:'
    print 'I0 = %.2f'%(popt_ha[0])
    #print 'n =  %.2f'%(popt_ha[1])
    print 'Re (arcsec)= %.2f'%(1./popt_ha[1])


    print'\nLINEAR FIT TO LOG(I)'
    print 'I0 = %.2f'%(np.exp(cc_ha[1]))
    #print 'n =  %.2f'%(popt[1])
    print 'Re (arcsec)= %.2f'%(-1./cc_ha[0])

    print '\nSExtractor Estimate for R50'
    print 'Re (arcsec)= %.2f'%(R50_ha)
    '''
